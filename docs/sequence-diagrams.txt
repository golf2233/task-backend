1. SIGNUP API

Key idea - Signup is write-only:
> No auth middleware
> No JWT yet
> Just data creation

User Browser
    |
    |  POST /signup  { email, password }
    |
    v
Express App (app.js)
    |
    |  route match
    v
Auth Routes (routes/auth.routes.js)
    |
    |  signup()
    v
Auth Controller (controllers/auth.controller.js)
    |
    |  bcrypt.hash(password)
    |  new User({...})
    |
    v
MongoDB (models/User.js)
    |
    |  insert user document
    |
    v
Auth Controller
    |
    |  res.json({ success: true })
    |
    v
User Browser

---------------------------------------------------

2. LOGIN API

Key idea - Login:
> Verifies identity
> Issues JWT
> Backend stays stateless

User Browser
    |
    |  POST /login  { email, password }
    |
    v
Express App
    |
    v
Auth Routes
    |
    |  login()
    v
Auth Controller
    |
    |  User.findOne(email)
    |  bcrypt.compare(password)
    |  jwt.sign({ userId })
    |
    v
User Browser
    |
    |  receives JWT token
    |  saves token (localStorage)

---------------------------------------------------

3. FETCH TASKS

Key idea
> Auth middleware injects identity
> Controller trusts req.userId
> User sees only their data

User Browser
    |
    |  GET /tasks
    |  Authorization: JWT
    |
    v
Express App
    |
    v
Task Routes (routes/task.routes.js)
    |
    |  auth middleware
    v
Auth Middleware (middleware/auth.middleware.js)
    |
    |  jwt.verify(token)
    |  req.userId = decoded.userId
    |
    v
Task Controller (controllers/task.controller.js)
    |
    |  Task.find({ userId })
    |
    v
MongoDB (models/Task.js)
    |
    |  return matching tasks
    |
    v
User Browser

---------------------------------------------------

4. ADD TASK

Key idea
> Frontend NEVER sends userId
> Ownership is enforced server-side

User Browser
    |
    |  POST /tasks
    |  Authorization: JWT
    |  { task }
    |
    v
Express App
    |
    v
Task Routes
    |
    |  auth middleware
    v
Auth Middleware
    |
    |  jwt.verify(token)
    |  req.userId set
    |
    v
Task Controller
    |
    |  new Task({ task, userId })
    |  save()
    |
    v
MongoDB
    |
    v
User Browser

---------------------------------------------------


Explanation of sequence flows:
---

# ğŸ§  Big Picture: Who Talks to Whom?

Browser (React)
   â†“ HTTP request
Routes (URL mapping)
   â†“
Middleware (auth)
   â†“
Controller (business logic)
   â†“
Model (MongoDB)
   â†‘
Response back to browser


This is the core loop of your backend.

---

# ğŸ§± Your Clean Backend Layers (Quick Map)

| Layer       | Folder         | Responsibility   |
| ----------- | -------------- | ---------------- |
| Bootstrap   | `server.js`    | Start server     |
| App setup   | `app.js`       | Express config   |
| Routing     | `routes/`      | URL â†’ controller |
| Middleware  | `middleware/`  | Security, checks |
| Controllers | `controllers/` | Business logic   |
| Models      | `models/`      | DB structure     |
| Config      | `config/`      | DB connection    |

Keep this table in your head â€” it never changes.

---

# ğŸ” SEQUENCE 1: User Signup Flow

### ğŸ¯ Goal

Create a new user account.
---

## ğŸŸ¦ Step-by-Step Flow

### 1ï¸âƒ£ Frontend (React)

```
fetch("/signup", { email, password })
```

ğŸ‘‰ â€œPlease create a new userâ€
---

### 2ï¸âƒ£ `server.js`

```
app.listen(...)
```

* Server is already running
* Request enters Express

(No logic here)

---

### 3ï¸âƒ£ `app.js`

```
app.use(authRoutes)
```

* Express receives `/signup`
* Passes it to auth routes

---

### 4ï¸âƒ£ `routes/auth.routes.js`

```
router.post("/signup", signup);
```

ğŸ‘‰ â€œPOST /signup should call `signup()`â€

No logic here â€” just mapping.

---

### 5ï¸âƒ£ `controllers/auth.controller.js`

```js
exports.signup = async (req, res) => {
  const hashedPassword = await bcrypt.hash(password);
  await user.save();
}
```

This is where **real work happens**:

* Hash password
* Create user
* Save to DB

---

### 6ï¸âƒ£ `models/User.js`

```js
new User({ email, password })
```

* Mongoose schema enforces structure
* MongoDB writes data

---

### 7ï¸âƒ£ Response Back

```json
{ "success": true }
```

Frontend shows:

> â€œSignup successfulâ€

---

# ğŸ” SEQUENCE 2: Login Flow (JWT Creation)

### ğŸ¯ Goal

Authenticate user and issue a token.

---

## ğŸŸ¦ Step-by-Step Flow

### 1ï¸âƒ£ Frontend

```js
fetch("/login", { email, password })
```

---

### 2ï¸âƒ£ `routes/auth.routes.js`

```js
router.post("/login", login);
```

---

### 3ï¸âƒ£ `controllers/auth.controller.js`

```js
const user = await User.findOne({ email });
bcrypt.compare(password);
jwt.sign({ userId });
```

Controller does:

* Find user
* Verify password
* Create JWT token

---

### 4ï¸âƒ£ Token Returned

```json
{ "token": "eyJhbGci..." }
```

Frontend:

* Saves token in `localStorage`
* Switches UI to dashboard

---

## ğŸ§  Important Insight

> **Backend never remembers sessions**
>
> Token = self-contained identity

This is why your backend is **stateless**.

---

# ğŸ” SEQUENCE 3: Fetch Tasks (Protected Route)

### ğŸ¯ Goal

Return only *this userâ€™s* tasks.

---

## ğŸŸ¦ Step-by-Step Flow

### 1ï¸âƒ£ Frontend

```js
fetch("/tasks", {
  headers: { Authorization: token }
})
```

---

### 2ï¸âƒ£ `routes/task.routes.js`

```js
router.get("/tasks", auth, getTasks);
```

ğŸ‘‰ **Important order**:

1. `auth`
2. `getTasks`

---

### 3ï¸âƒ£ `middleware/auth.middleware.js`

```js
jwt.verify(token)
req.userId = decoded.userId
next()
```

This middleware:

* Verifies token
* Extracts user ID
* Attaches it to request

ğŸš¨ If token is invalid â†’ request stops here.

---

### 4ï¸âƒ£ `controllers/task.controller.js`

```js
Task.find({ userId: req.userId })
```

Controller:

* Uses **identity from middleware**
* Queries only that userâ€™s data

---

### 5ï¸âƒ£ `models/Task.js`

MongoDB returns:

```json
[
  { "task": "Task 1", "userId": "abc" }
]
```

---

### 6ï¸âƒ£ Response Back

Frontend updates UI.

---

# ğŸ” SEQUENCE 4: Add Task (Protected Write)

### ğŸ¯ Goal

Create a task owned by the logged-in user.

---

## ğŸŸ¦ Step-by-Step Flow

### 1ï¸âƒ£ Frontend

```js
POST /tasks
Authorization: token
Body: { task }
```

---

### 2ï¸âƒ£ Route â†’ Middleware â†’ Controller

```
/tasks
 â†’ auth middleware
 â†’ addTask controller
```

---

### 3ï¸âƒ£ `middleware/auth.middleware.js`

Sets:

```js
req.userId = decoded.userId
```

---

### 4ï¸âƒ£ `controllers/task.controller.js`

```js
new Task({
  task: req.body.task,
  userId: req.userId
})
```

ğŸ’¡ **Frontend never sends userId**
Backend decides ownership.

---

### 5ï¸âƒ£ DB Save â†’ Response

```json
{ "success": true }
```

Frontend re-fetches tasks.

---

# ğŸ” Why This Architecture Is Correct

### âŒ Bad design

* Controllers reading token
* Routes querying DB
* UI sending userId

### âœ… Your design

* Middleware handles auth
* Controllers handle logic
* Models handle DB
* Routes handle URLs

Each layer does **one job**.

---

# ğŸ§  The Most Important Mental Model

> **Request = packet traveling through layers**

```
Request
 â†’ Route (where?)
 â†’ Middleware (allowed?)
 â†’ Controller (what to do?)
 â†’ Model (store/read)
 â†’ Response
```

This model applies to:

* Payments
* Webhooks
* Admin APIs
* Anything youâ€™ll build next

---

# ğŸ Summary (Remember Only 5 Things)

1ï¸âƒ£ `server.js` starts the engine
2ï¸âƒ£ `app.js` wires middleware & routes
3ï¸âƒ£ Routes map URLs â†’ controllers
4ï¸âƒ£ Middleware protects requests
5ï¸âƒ£ Controllers never care about HTTP details

---